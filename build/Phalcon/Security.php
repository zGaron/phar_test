<?php
/**
 * Security
 *
*/
namespace Phalcon;

use \Phalcon\DiInterface;
use \Phalcon\Di\InjectionAwareInterface;
use \Phalcon\Security\Exception;
use \Phalcon\Session\AdapterInterface as SessionInterface;
use \Phalcon\Text;
/**
 * Phalcon\Security
 *
 * This component provides a set of functions to improve the security in Scene applications
 *
 *<code>
 *  $login = $this->request->getPost('login');
 *  $password = $this->request->getPost('password');
 *
 *  $user = Users::findFirstByLogin($login);
 *  if ($user) {
 *      if ($this->security->checkHash($password, $user->password)) {
 *          //The password is valid
 *      }
 *  }
 *</code>
 *
 */
class Security implements InjectionAwareInterface
{
    
    /**
     * Dependency Injector
     *
     * @var null|\Phalcon\DiInterface
     * @var protected
    */
    protected $_dependencyInjector;

    /**
     * Work Factor
     *
     * @var int
     * @access protected
    */
    protected $_workFactor = 8;

    /**
     * Number of Bytes
     *
     * @var int
     * @access protected
    */
    protected $_numberBytes = 16;

    /**
     * TokenKey SessionID
     *
     * @var string
     * @access protected
    */
    protected $_tokenKeySessionID = '$SCENE/CSRF/KEY$';

    /**
     * TokenValue SessionID
     *
     * @var string
     * @access protected
    */
    protected $_tokenValueSessionID = '$SCENE/CSRF$';

    /**
     * CSRF
     *
     * @var null
     * @access protected
    */
    protected $_csrf;

    /**
     * Default Hash
     *
     * @var null
     * @access protected
    */
    protected $_defaultHash;

    const CRYPT_DEFAULT    =    0;

    const CRYPT_STD_DES    =    1;

    const CRYPT_EXT_DES    =    2;

    const CRYPT_MD5        =    3;

    const CRYPT_BLOWFISH       =    4;

    const CRYPT_BLOWFISH_X     =    5;

    const CRYPT_BLOWFISH_Y     =    6;

    const CRYPT_SHA256     =    7;

    const CRYPT_SHA512     =    8;

    /**
     * Sets the dependency injector
     *
     * @param \Phalcon\DiInterface $dependencyInjector
     * @throws Exception
     */
    public function setDI($dependencyInjector)
    {
        if (!is_object($dependencyInjector) ||
            $dependencyInjector instanceof DiInterface === false) {
            throw new Exception('Invalid parameter type.');
        }

        $this->_dependencyInjector = $dependencyInjector;
    }

    /**
     * Returns the internal dependency injector
     *
     * @return \Phalcon\DiInterface|null
     */
    public function getDI()
    {
        return $this->_dependencyInjector;
    }

    /**
     * Sets a number of bytes to be generated by the openssl pseudo random generator
     *
     * @param int $randomBytes
     * @throws Exception
     */
    public function setRandomBytes($randomBytes)
    {
        if (!is_int($randomBytes)) {
            throw new Exception('Invalid parameter type.');
        }

        $this->_numberBytes = $randomBytes;
    }

    /**
     * Returns a number of bytes to be generated by the openssl pseudo random generator
     *
     * @return int
     */
    public function getRandomBytes()
    {
        return $this->_numberBytes;
    }

    /**
     * Sets the default working factor for bcrypts password's salts
     *
     * @param int $workFactor
     * @throws Exception
     */
    public function setWorkFactor($workFactor)
    {
        if (is_int($workFactor) === false) {
            throw new Exception('Invalid parameter type.');
        }

        $this->_workFactor = $workFactor;
    }

    /**
     * Returns the default working factor for bcrypts password's salts
     *
     * @return int
     */
    public function getWorkFactor()
    {
        return $this->_workFactor;
    }

    /**
     * Alphanumerical Filter
     *
     * @param string $value
     * @return string
    */
    protected static function filterAlnum($value)
    {
        $filtered = '';
        $value = (string)$value;
        $valueLength = strlen($value);
        $zeroChar = chr(0);

        for ($i = 0; $i < $valueLength; $i++) {
            if ($value[$i] == $zeroChar) {
                break;
            }

            if (ctype_alnum($value[$i]) === true) {
                $filtered .= $value[$i];
            }
        }

        return $filtered;
    }

    /**
     * Generate a >22-length pseudo random string to be used as salt for passwords
     *
     * @param int $numberBytes
     * @return string
     * @throws Exception
     */
    public function getSaltBytes($numberBytes = 0)
    {
        if (!function_exists('openssl_random_pseudo_bytes')) {
            throw new Exception('Openssl extension must be loaded');
        }

        $safeBytes = '';

        
        if (!$numberBytes) {
            $numberBytes = (int) $this->_numberBytes;
        }

        while (strlen($safeBytes) < $numberBytes) {

            $safeBytes = self::filterAlnum(base64_encode(openssl_random_pseudo_bytes($numberBytes)));

            if (empty($safeBytes)) {
                continue;
            }
        }

        return $safeBytes;
    }

    /**
     * Creates a password hash using bcrypt with a pseudo random salt
     *
     * @param string $password
     * @param int|null $workFactor
     * @return string
     * @throws Exception
     */
    public function hash($password, $workFactor = 0)
    {
        if (!is_string($password)) {
            throw new Exception('Invalid parameter type.');
        }

        if (is_int($workFactor) === false) {
            throw new Exception('Invalid parameter type.');
        }

        if (!$workFactor) {
            $workFactor = (int) $this->_workFactor;
        }

        $hash = (int) $this->_defaultHash;

        switch ($hash) {

            case self::CRYPT_BLOWFISH_X:
                $variant = "x";
                break;

            case self::CRYPT_BLOWFISH_Y:
                $variant = "y";
                break;

            case self::CRYPT_SHA256:
                $variant = "5";
                break;

            case self::CRYPT_SHA512:
                $variant = "6";
                break;

            case self::CRYPT_MD5:
                $variant = "1";
                break;

            case self::CRYPT_DEFAULT:
            default:
                $variant = "a";
                break;
        }

        switch ($hash) {
            case self::CRYPT_STD_DES:
                
                /* Standard DES-based hash with a two character salt from the alphabet "./0-9A-Za-z". */
                
                $safeBytes = $this->getSaltBytes(2);
                if (!is_string($safeBytes)) {
                    throw new Exception("Unable to get random bytes for the salt");
                }
                return crypt($password, $safeBytes);

            case self::CRYPT_EXT_DES:

                $safeBytes = $this->getSaltBytes(4);
                if (!is_string($safeBytes)) {
                    throw new Exception("Unable to get random bytes for the salt");
                }
                return crypt($password, '_12..' . $safeBytes);

            case self::CRYPT_SHA256:

                $safeBytes = $this->getSaltBytes(8);
                if (!is_string($safeBytes)) {
                    throw new Exception("Unable to get random bytes for the salt");
                }
                return crypt($password, '$' . $variant . '$' . $safeBytes);
           
            case self::CRYPT_SHA512:

                $safeBytes = $this->getSaltBytes(8);
                if (!is_string($safeBytes)) {
                    throw new Exception("Unable to get random bytes for the salt");
                }
                return crypt($password, '$' . $variant . '$' . $safeBytes);

            case self::CRYPT_MD5:

                $safeBytes = $this->getSaltBytes(6);
                if (!is_string($safeBytes)) {
                    throw new Exception("Unable to get random bytes for the salt");
                }
                return crypt($password, '$' . $variant . '$' . $safeBytes);

            case self::CRYPT_DEFAULT:
            case self::CRYPT_BLOWFISH:
            case self::CRYPT_BLOWFISH_X:
            case self::CRYPT_BLOWFISH_Y:
            default:
                
                /*
                 * Blowfish hashing with a salt as follows: "$2a$", "$2x$" or "$2y$",
                 * a two digit cost parameter, "$", and 22 characters from the alphabet
                 * "./0-9A-Za-z". Using characters outside of this range in the salt
                 * will cause crypt() to return a zero-length string. The two digit cost
                 * parameter is the base-2 logarithm of the iteration count for the
                 * underlying Blowfish-based hashing algorithm and must be in
                 * range 04-31, values outside this range will cause crypt() to fail.
                 */
                
                $safeBytes = $this->getSaltBytes(22);
                if (!is_string($safeBytes)) {
                    throw new Exception("Unable to get random bytes for the salt");
                }

                if ($workFactor < 4) {
                    $workFactor = 4;
                } else {
                    if ($workFactor > 31) {
                        $workFactor = 31;
                    }
                }

                return crypt($password, '$2' . $variant . '$' . sprintf('%02s', $workFactor) . '$' . $safeBytes);
        }

        return '';
    }

    /**
     * Checks a plain text password and its hash version to check if the password matches
     *
     * @param string $password
     * @param string $passwordHash
     * @param int|null $maxPassLength
     * @return boolean|null
     * @throws Exception
     */
    public function checkHash($password, $passwordHash, $maxPassLength = 0)
    {
        /* Type check */
        if (!is_string($password) || !is_string($passwordHash)) {
            throw new Exception('Invalid parameter type.');
        }

        if (!is_int($maxPassLength)) {
            throw new Exception('Invalid parameter type.');
        }

        if ($maxPassLength) {
            if ($maxPassLength > 0 && strlen($password) > $maxPassLength) {
                return false;
            }
        }

        $cryptedHash = (string) crypt($password, $passwordHash);

        $cryptLength = strlen($cryptedHash);
        $passwordLenght = strlen($passwordHash);

        $cryptedHash .= $passwordHash;

        $sum = $cryptLength - $passwordLenght;

        for ($i=0; $i <  $cryptLength; $i++) { 
            $sum = $sum | (ord($cryptedHash[$i])) ^ (ord($passwordHash[$i]));
        }

        return 0 === $sum;
    }

    /**
     * Checks if a password hash is a valid bcrypt's hash
     *
     * @param string $passwordHash
     * @return boolean
     * @throws Exception
     */
    public function isLegacyHash($passwordHash)
    {
        if (!is_string($passwordHash)) {
            throw new Exception('Invalid parameter type.');
        }

        return (Text::startsWith($passwordHash, '$2a$'));
    }

    /**
     * Generates a pseudo random token key to be used as input's name in a CSRF check
     *
     * @param int|null $numberBytes
     * @return string
     * @throws Exception
     */
    public function getTokenKey($numberBytes = null)
    {
        if (is_null($numberBytes)) {
            $numberBytes = 12;
        } elseif (!is_int($numberBytes)) {
            throw new Exception('Invalid parameter type.');
        }

        if (!function_exists('openssl_random_pseudo_bytes')) {
            throw new SecException('Openssl extension must be loaded');
        }

        $safeBytes = self::filterAlnum(base64_encode(openssl_random_pseudo_bytes($numberBytes)));

        //@warning no length check for $safeBytes

        if (!is_object($this->_dependencyInjector)) {
            throw new Exception('A dependency injection container is required to access the \'session\' service');
        }

        $session = $this->_dependencyInjector->getShared('session');

        $session->set($this->_tokenKeySessionID, $safeBytes);
    }

    /**
     * Generates a pseudo random token value to be used as input's value in a CSRF check
     *
     * @param int|null $numberBytes
     * @return string
     * @throws Exception
     */
    public function getToken($numberBytes = null)
    {
        if (is_null($numberBytes)) {
            $numberBytes = 12;
        } elseif (!is_int($numberBytes)) {
            throw new Exception('Invalid parameter type.');
        }

        if (!function_exists('openssl_random_pseudo_bytes')) {
            throw new SecException('Openssl extension must be loaded');
        }

        $token = self::filterAlnum(base64_encode(openssl_random_pseudo_bytes($numberBytes)));

        if (!is_object($this->_dependencyInjector)) {
            throw new Exception('A dependency injection container is required to access the \'session\' service');
        }

        $session = $this->_dependencyInjector->getShared('session');
        $session->set($this->_tokenValueSessionID, $token);

        return $token;
    }

    /**
     * Check if the CSRF token sent in the request is the same that the current in session
     *
     * @param mixed $tokenKey
     * @param mixed $tokenValue
     * @param boolean $destroyIfValid
     * @return boolean
     * @throws Exception
     */
    public function checkToken($tokenKey = null, $tokenValue = null, $destroyIfValid = true)
    {

        $dependencyInjector = $this->_dependencyInjector;
        
        if (!is_object($dependencyInjector)) {
            throw new Exception('A dependency injection container is required to access the \'session\' service');
        }

        $session = $dependencyInjector->getShared('session');

        if (!$tokenKey) {
            $tokenKey = $session->get($this->_tokenKeySessionID);
        }

        /**
         * If tokenKey does not exist in session return false
         */
        if (!$tokenKey) {
            return false;
        }

        if (!$tokenValue) {
            $request = $dependencyInjector->getShared('request');

            /**
             * We always check if the value is correct in post
             */
            $token = $request->getPost($tokenKey);
        } else {
            $token = $tokenValue;
        }

        /**
         * The value is the same?
         */
        $returnValue = ($token == $session->get($this->_tokenValueSessionID));

        /**
         * Remove the key and value of the CSRF token in session
         */
        if ($returnValue && $destroyIfValid) {
            $session->remove($this->_tokenKeySessionID);
            $session->remove($this->_tokenValueSessionID);
        }

        return $returnValue;
    }

    /**
     * Returns the value of the CSRF token in session
     *
     * @return string
     * @throws Exception
     */
    public function getSessionToken()
    {
        $dependencyInjector = $this->_dependencyInjector;
        
        if (!is_object($dependencyInjector)) {
            throw new Exception('A dependency injection container is required to access the \'session\' service');
        }

        $session = $dependencyInjector->getShared('session');

        return $session->get($this->_tokenValueSessionID);
    }

    /**
     * Removes the value of the CSRF token and key from session
     *
     * @throws Exception
     */
    public function destoryToken()
    {
        $dependencyInjector = $this->_dependencyInjector;
        
        if (!is_object($dependencyInjector)) {
            throw new Exception('A dependency injection container is required to access the \'session\' service');
        }

        $session = $dependencyInjector->getShared('session');

        $session->remove($this->_tokenKeySessionID);
        $session->remove($this->_tokenValueSessionID);

    }

    /**
     * Computes a HMAC
     *
     * @param string data
     * @param string key
     * @param string algo
     * @param boolean raw
     */
    public function computeHmac($data, $key, $algo, $raw = false)
    {
        $hmac = hash_hmac($algo, $data, $key, $raw);
        if (!$hmac) {
            throw new Exception("Unknown hashing algorithm: %s" . algo);
        }

        return $hmac;
    }

    /**
     * Sets the default hash
     */
    public function setDefaultHash($defaultHash)
    {
        $this->_defaultHash = $defaultHash;
    }

    /**
     * Sets the default hash
     */
    public function getDefaultHash()
    {
        return $this->_defaultHash;
    }
}
